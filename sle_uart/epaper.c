#include "epaper.h"
#include "gpio.h"
#include "pinctrl.h"
#include "soc_osal.h"
#include "spi.h"
#include "stdio.h"

static const uint8_t EPD_lut_R20_GC[] =
    {
        0x01, 0x0f, 0x0f, 0x0f, 0x01, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static const uint8_t EPD_lut_R21_GC[] =
    {
        0x01, 0x4f, 0x8f, 0x0f, 0x01, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static const uint8_t EPD_lut_R22_GC[] =
    {
        0x01, 0x0f, 0x8f, 0x0f, 0x01, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static const uint8_t EPD_lut_R23_GC[] =
    {
        0x01, 0x4f, 0x8f, 0x4f, 0x01, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static const uint8_t EPD_lut_R24_GC[] =
    {
        0x01, 0x0f, 0x8f, 0x4f, 0x01, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

// DU 0.3s
static const uint8_t EPD_lut_R20_DU[] =
    {
        0x01, 0x0f, 0x01, 0x00, 0x00, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static const uint8_t EPD_lut_R21_DU[] =
    {
        0x01, 0x0f, 0x01, 0x00, 0x00, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static const uint8_t EPD_lut_R22_DU[] =
    {
        0x01, 0x8f, 0x01, 0x00, 0x00, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static const uint8_t EPD_lut_R23_DU[] =
    {
        0x01, 0x4f, 0x01, 0x00, 0x00, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
static const uint8_t EPD_lut_R24_DU[] =
    {
        0x01, 0x0f, 0x01, 0x00, 0x00, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

//
static const uint8_t EPD_lut_vcom[] =
    {
        0x01, 0x19, 0x19, 0x19, 0x19, 0x01, 0x01,
        0x01, 0x19, 0x19, 0x19, 0x01, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

static const uint8_t EPD_lut_ww[] =
    {
        0x01, 0x59, 0x99, 0x59, 0x99, 0x01, 0x01,
        0x01, 0x59, 0x99, 0x19, 0x01, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

};

static const uint8_t EPD_lut_bw[] =
    {
        0x01, 0x59, 0x99, 0x59, 0x99, 0x01, 0x01,
        0x01, 0x59, 0x99, 0x19, 0x01, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

static const uint8_t EPD_lut_wb[] =
    {
        0x01, 0x19, 0x99, 0x59, 0x99, 0x01, 0x01,
        0x01, 0x59, 0x99, 0x59, 0x01, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

static const uint8_t EPD_lut_bb[] =
    {
        0x01, 0x19, 0x99, 0x59, 0x99, 0x01, 0x01,
        0x01, 0x59, 0x99, 0x59, 0x01, 0x01, 0x01,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

unsigned char EPD_Flag = 0;

/// @brief 重置
void EPD_Reset(void) {
    uapi_gpio_set_val(CONFIG_EPD_RST_PIN, GPIO_LEVEL_HIGH);
    osal_mdelay(200);
    uapi_gpio_set_val(CONFIG_EPD_RST_PIN, GPIO_LEVEL_LOW);
    osal_mdelay(2);
    uapi_gpio_set_val(CONFIG_EPD_RST_PIN, GPIO_LEVEL_HIGH);
    osal_mdelay(200);
}

void uapi_spi_master_write_byte(uint8_t byte) {
    spi_xfer_data_t data = {0};
    uint8_t buff[] = {byte};
    data.tx_buff = buff;
    data.tx_bytes = sizeof(buff);
    uint32_t ret = uapi_spi_master_write(CONFIG_EPD_MASTER_BUS_ID, &data, 1000);
    if (ret != 0) {
        printf("spi = %0x master send failed\r\n", ret);
    }
}

/// @brief 发送指令
/// @param reg 指令
void EPD_SendCommand(uint8_t reg) {
    uapi_gpio_set_val(CONFIG_EPD_DC_PIN, GPIO_LEVEL_LOW);
    uapi_gpio_set_val(CONFIG_EPD_CS_PIN, GPIO_LEVEL_LOW);
    uapi_spi_master_write_byte(reg);
    uapi_gpio_set_val(CONFIG_EPD_CS_PIN, GPIO_LEVEL_HIGH);
}

/// @brief 发送数据
/// @param Data 数据
void EPD_SendData(uint8_t Data) {
    uapi_gpio_set_val(CONFIG_EPD_DC_PIN, GPIO_LEVEL_HIGH);
    uapi_gpio_set_val(CONFIG_EPD_CS_PIN, GPIO_LEVEL_LOW);
    uapi_spi_master_write_byte(Data);
    uapi_gpio_set_val(CONFIG_EPD_CS_PIN, GPIO_LEVEL_HIGH);
}

/// @brief 读取忙
void EPD_ReadBusy(void) {
    printf("e-Paper busy\r\n");
    uint8_t busy;
    do {
        busy = uapi_gpio_get_val(CONFIG_EPD_BUSY_PIN);
    } while (!busy);
    osal_mdelay(200);
    printf("e-Paper busy release\r\n");
}

/// @brief 刷新屏幕
void EPD_refresh(void) {
    EPD_SendCommand(0x17);
    EPD_SendData(0xA5);
    EPD_ReadBusy();
    osal_mdelay(200);
}

/// @brief LUT
void EPD_lut(void) {
    uint8_t count;
    EPD_SendCommand(0x20); // vcom
    for (count = 0; count < 42; count++) {
        EPD_SendData(EPD_lut_vcom[count]);
    }

    EPD_SendCommand(0x21); // ww --
    for (count = 0; count < 42; count++) {
        EPD_SendData(EPD_lut_ww[count]);
    }

    EPD_SendCommand(0x22); // bw r
    for (count = 0; count < 42; count++) {
        EPD_SendData(EPD_lut_bw[count]);
    }

    EPD_SendCommand(0x23); // wb w
    for (count = 0; count < 42; count++) {
        EPD_SendData(EPD_lut_bb[count]);
    }

    EPD_SendCommand(0x24); // bb b
    for (count = 0; count < 42; count++) {
        EPD_SendData(EPD_lut_wb[count]);
    }
}

/// @brief LUT下载
void EPD_lut_GC(void) {
    uint8_t count;
    EPD_SendCommand(0x20); // vcom
    for (count = 0; count < 56; count++) {
        EPD_SendData(EPD_lut_R20_GC[count]);
    }

    EPD_SendCommand(0x21); // red not use
    for (count = 0; count < 42; count++) {
        EPD_SendData(EPD_lut_R21_GC[count]);
    }

    EPD_SendCommand(0x24); // bb b
    for (count = 0; count < 42; count++) {
        EPD_SendData(EPD_lut_R24_GC[count]);
    }

    if (EPD_Flag == 0) {
        EPD_SendCommand(0x22); // bw r
        for (count = 0; count < 56; count++) {
            EPD_SendData(EPD_lut_R22_GC[count]);
        }

        EPD_SendCommand(0x23); // wb w
        for (count = 0; count < 42; count++) {
            EPD_SendData(EPD_lut_R23_GC[count]);
        }

        EPD_Flag = 1;
    } else {
        EPD_SendCommand(0x22); // bw r
        for (count = 0; count < 56; count++) {
            EPD_SendData(EPD_lut_R23_GC[count]);
        }

        EPD_SendCommand(0x23); // wb w
        for (count = 0; count < 42; count++) {
            EPD_SendData(EPD_lut_R22_GC[count]);
        }

        EPD_Flag = 0;
    }
}

/// @brief LUT下载
void EPD_lut_DU(void) {
    uint8_t count;
    EPD_SendCommand(0x20); // vcom
    for (count = 0; count < 56; count++) {
        EPD_SendData(EPD_lut_R20_DU[count]);
    }

    EPD_SendCommand(0x21); // red not use
    for (count = 0; count < 42; count++) {
        EPD_SendData(EPD_lut_R21_DU[count]);
    }

    EPD_SendCommand(0x24); // bb b
    for (count = 0; count < 42; count++) {
        EPD_SendData(EPD_lut_R24_DU[count]);
    }

    if (EPD_Flag == 0) {
        EPD_SendCommand(0x22); // bw r
        for (count = 0; count < 56; count++) {
            EPD_SendData(EPD_lut_R22_DU[count]);
        }

        EPD_SendCommand(0x23); // wb w
        for (count = 0; count < 42; count++) {
            EPD_SendData(EPD_lut_R23_DU[count]);
        }

        EPD_Flag = 1;
    } else {
        EPD_SendCommand(0x22); // bw r
        for (count = 0; count < 56; count++) {
            EPD_SendData(EPD_lut_R23_DU[count]);
        }

        EPD_SendCommand(0x23); // wb w
        for (count = 0; count < 42; count++) {
            EPD_SendData(EPD_lut_R22_DU[count]);
        }

        EPD_Flag = 0;
    }
}

/// @brief 初始化墨水屏
void EPD_Init(void) {
    EPD_Flag = 0;
    EPD_Reset();

    EPD_SendCommand(0x00); // panel setting   PSR
    EPD_SendData(0xFF);    // RES1 RES0 REG KW/R     UD    SHL   SHD_N  RST_N
    EPD_SendData(0x01);    // x x x VCMZ TS_AUTO TIGE NORG VC_LUTZ

    EPD_SendCommand(0x01); // POWER SETTING   PWR
    EPD_SendData(0x03);    //  x x x x x x VDS_EN VDG_EN
    EPD_SendData(0x10);    //  x x x VCOM_SLWE VGH[3:0]   VGH=20V, VGL=-20V
    EPD_SendData(0x3F);    //  x x VSH[5:0]	VSH = 15V
    EPD_SendData(0x3F);    //  x x VSL[5:0]	VSL=-15V
    EPD_SendData(0x03);    //  OPTEN VDHR[6:0]  VHDR=6.4V
                           // T_VDS_OFF[1:0] 00=1 frame; 01=2 frame; 10=3 frame; 11=4 frame
    EPD_SendCommand(0x06); // booster soft start   BTST
    EPD_SendData(0x37);    //  BT_PHA[7:0]
    EPD_SendData(0x3D);    //  BT_PHB[7:0]
    EPD_SendData(0x3D);    //  x x BT_PHC[5:0]

    EPD_SendCommand(0x60); // TCON setting			TCON
    EPD_SendData(0x22);    // S2G[3:0] G2S[3:0]   non-overlap = 12

    EPD_SendCommand(0x82); // VCOM_DC setting		VDCS
    EPD_SendData(0x07);    // x  VDCS[6:0]	VCOM_DC value= -1.9v    00~3f,0x12=-1.9v

    EPD_SendCommand(0x30);
    EPD_SendData(0x09);

    EPD_SendCommand(0xe3); // power saving			PWS
    EPD_SendData(0x88);    // VCOM_W[3:0] SD_W[3:0]

    EPD_SendCommand(0x61); // resoultion setting
    EPD_SendData(0xf0);    //  HRES[7:3] 0 0 0
    EPD_SendData(0x01);    //  x x x x x x x VRES[8]
    EPD_SendData(0x68);    //  VRES[7:0]

    EPD_SendCommand(0x50);
    EPD_SendData(0xB7);
}

void EPD_display(uint8_t *picData) {
    uint16_t i;
    EPD_SendCommand(0x13); // Transfer new data
    for (i = 0; i < (EPD_WIDTH * EPD_HEIGHT / 8); i++) {
        EPD_SendData(*picData);
        picData++;
    }
}

void EPD_display_NUM(uint8_t NUM) {
    uint16_t row, column;
    // UWORD pcnt = 0;

    EPD_SendCommand(0x13); // Transfer new data

    for (column = 0; column < EPD_HEIGHT; column++) {
        for (row = 0; row < EPD_WIDTH / 8; row++) {
            switch (NUM) {
            case EPD_WHITE:
                EPD_SendData(0xFF);
                break;

            case EPD_BLACK:
                EPD_SendData(0x00);
                break;

            case EPD_Source_Line:
                EPD_SendData(0xAA);
                break;

            case EPD_Gate_Line:
                if (column % 2)
                    EPD_SendData(0xff); // An odd number of Gate line
                else
                    EPD_SendData(0x00); // The even line Gate
                break;

            case EPD_Chessboard:
                if (row >= (EPD_WIDTH / 8 / 2) && column >= (EPD_HEIGHT / 2))
                    EPD_SendData(0xff);
                else if (row < (EPD_WIDTH / 8 / 2) && column < (EPD_HEIGHT / 2))
                    EPD_SendData(0xff);
                else
                    EPD_SendData(0x00);
                break;

            case EPD_LEFT_BLACK_RIGHT_WHITE:
                if (row >= (EPD_WIDTH / 8 / 2))
                    EPD_SendData(0xff);
                else
                    EPD_SendData(0x00);
                break;

            case EPD_UP_BLACK_DOWN_WHITE:
                if (column >= (EPD_HEIGHT / 2))
                    EPD_SendData(0xFF);
                else
                    EPD_SendData(0x00);
                break;

            case EPD_Frame:
                if (column == 0 || column == (EPD_HEIGHT - 1))
                    EPD_SendData(0x00);
                else if (row == 0)
                    EPD_SendData(0x7F);
                else if (row == (EPD_WIDTH / 8 - 1))
                    EPD_SendData(0xFE);
                else
                    EPD_SendData(0xFF);
                break;

            case EPD_Crosstalk:
                if ((row >= (EPD_WIDTH / 8 / 3) && row <= (EPD_WIDTH / 8 / 3 * 2) && column <= (EPD_HEIGHT / 3)) || (row >= (EPD_WIDTH / 8 / 3) && row <= (EPD_WIDTH / 8 / 3 * 2) && column >= (EPD_HEIGHT / 3 * 2)))
                    EPD_SendData(0x00);
                else
                    EPD_SendData(0xFF);
                break;

            case EPD_Image:
                // EPD_SendData(gImage_1[pcnt++]);
                break;

            default:
                break;
            }
        }
    }
}

/// @brief 清除屏幕
void EPD_Clear(void) {
    uint16_t i;
    EPD_SendCommand(0x13);
    for (i = 0; i < (EPD_WIDTH * EPD_HEIGHT / 8); i++) {
        EPD_SendData(EPD_WHITE);
    }
    EPD_lut_GC();
    EPD_refresh();
}

/// @brief 进入睡眠模式
void EPD_sleep(void) {
    EPD_SendCommand(0X07);
    EPD_SendData(0xA5);
}